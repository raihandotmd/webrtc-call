<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Caller B</title>
</head>
<body>
  <h1>Caller B</h1>
  <div>
    <button id="connectBtn">Connect to Server</button>
    <button id="callBtn" disabled>Call Client A</button>
    <button id="hangupBtn" disabled>Hang Up</button>
    <button id="muteBtn" disabled style="background: #ff9800; color: white; padding: 8px 16px; margin: 5px;">ðŸŽ¤ Mute</button>
  </div>
  
  <!-- Incoming call notification -->
  <div id="incomingCallDiv" style="display: none; background: #f0f8ff; padding: 15px; border: 2px solid #4CAF50; border-radius: 5px; margin: 10px 0;">
    <h3>ðŸ“ž Incoming Call from Client <span id="callerName"></span></h3>
    <button id="acceptBtn" style="background: #4CAF50; color: white; padding: 10px 20px; margin: 5px;">Accept</button>
    <button id="rejectBtn" style="background: #f44336; color: white; padding: 10px 20px; margin: 5px;">Reject</button>
  </div>
  
  <div>
    <p>Status: <span id="status">Disconnected</span></p>
    <p>Call State: <span id="callState">No Call</span></p>
  </div>
  <audio id="remoteAudio" autoplay></audio>
  
  <script>
    const clientId = "2";
    const remoteClientId = "1";
    
    let ws = null;
    let pc = null;
    let localStream = null;
    let isMuted = false;
    let pendingIceCandidates = []; // Queue for ICE candidates received before remote description
    
    const connectBtn = document.getElementById("connectBtn");
    const callBtn = document.getElementById("callBtn");
    const hangupBtn = document.getElementById("hangupBtn");
    const muteBtn = document.getElementById("muteBtn");
    const acceptBtn = document.getElementById("acceptBtn");
    const rejectBtn = document.getElementById("rejectBtn");
    const incomingCallDiv = document.getElementById("incomingCallDiv");
    const callerName = document.getElementById("callerName");
    const status = document.getElementById("status");
    const callState = document.getElementById("callState");
    const remoteAudio = document.getElementById("remoteAudio");

    // Update UI status
    function updateStatus(message) {
      status.textContent = message;
      console.log("Status:", message);
    }

    function updateCallState(state) {
      callState.textContent = state;
      console.log("Call State:", state);
    }

    // Configuration - Update these for different environments
    const CONFIG = {
      // For local development
      LOCAL: {
        host: window.location.hostname + ':8081',
        protocol: 'ws:'
      },
      // For ngrok tunnel
      NGROK: {
        host: '5715bbea92bf.ngrok-free.app',
        protocol: 'wss:'
      }
    };
    
    // Switch between LOCAL and NGROK here
    const CURRENT_ENV = 'LOCAL'; // Change to 'LOCAL' for local development
    
    const proxyHost = CONFIG[CURRENT_ENV].host;
    const wsProtocol = CONFIG[CURRENT_ENV].protocol;

    // Check and request microphone permissions early
    async function checkMicrophonePermission() {
      try {
        // Check if permissions API is available
        if ('permissions' in navigator) {
          const permission = await navigator.permissions.query({ name: 'microphone' });
          console.log("Microphone permission state:", permission.state);
          
          if (permission.state === 'denied') {
            updateStatus("Microphone access denied. Please enable in browser settings.");
            alert("Microphone access is required for calls. Please enable it in your browser settings and refresh the page.");
            return false;
          }
        }
        
        // For mobile browsers, request permission early
        const testStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        testStream.getTracks().forEach(track => track.stop()); // Clean up test stream
        console.log("Microphone permission granted");
        return true;
      } catch (error) {
        console.error("Microphone permission check failed:", error);
        if (error.name === 'NotAllowedError') {
          updateStatus("Microphone permission denied. Please allow access.");
          alert("Microphone access is required for calls. Please allow when prompted and refresh if needed.");
        }
        return false;
      }
    }

    // Mute/Unmute microphone
    function toggleMute() {
      if (!localStream) {
        console.log("No local stream to mute");
        return;
      }

      const audioTracks = localStream.getAudioTracks();
      if (audioTracks.length === 0) {
        console.log("No audio tracks to mute");
        return;
      }

      isMuted = !isMuted;
      
      // Toggle all audio tracks
      audioTracks.forEach(track => {
        track.enabled = !isMuted;
      });

      // Update button appearance
      if (isMuted) {
        muteBtn.innerHTML = "ðŸ”‡ Unmute";
        muteBtn.style.background = "#f44336"; // Red when muted
        console.log("Microphone muted");
      } else {
        muteBtn.innerHTML = "ðŸŽ¤ Mute";
        muteBtn.style.background = "#ff9800"; // Orange when unmuted
        console.log("Microphone unmuted");
      }
    }

    // Request ICE servers configuration via WebSocket
    function requestIceServers() {
      return new Promise((resolve, reject) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          console.error("WebSocket not connected, using fallback STUN server");
          resolve([{ urls: "stun:stun.l.google.com:19302" }]);
          return;
        }

        // Set up one-time listener for ICE servers response
        const handleICEResponse = (event) => {
          const message = JSON.parse(event.data);
          if (message.success && message.data.event === 'call_ice_servers_response') {
            ws.removeEventListener('message', handleICEResponse);
            console.log("Received ICE servers via WebSocket");
            
            // Transform backend response to WebRTC format
            const iceServers = message.data.data.ice_servers.map(server => {
              const transformedServer = {
                urls: server.urls
              };
              
              if (server.username) {
                transformedServer.username = server.username;
              }
              if (server.credential) {
                transformedServer.credential = server.credential;
              }
              
              console.log("Transformed ICE server:", transformedServer);
              return transformedServer;
            });
            
            resolve(iceServers);
          } else if (!message.success) {
            ws.removeEventListener('message', handleICEResponse);
            console.error("ICE servers request error:", message.error);
            // Use fallback STUN server
            resolve([{ urls: "stun:stun.l.google.com:19302" }]);
          }
        };
        
        ws.addEventListener('message', handleICEResponse);
        
        
        ws.send(JSON.stringify({
          event: 'call_ice_servers_request',
          data: {}
        }));
        
        // Timeout after 5 seconds
        setTimeout(() => {
          ws.removeEventListener('message', handleICEResponse);
          console.warn("ICE servers request timeout, using fallback");
          resolve([{ urls: "stun:stun.l.google.com:19302" }]);
        }, 5000);
      });
    }

    // Initialize WebRTC peer connection
    async function createPeerConnection() {
      const iceServers = await requestIceServers();
      
      pc = new RTCPeerConnection({ 
        iceServers,
        // Add configuration for better ICE handling
        iceCandidatePoolSize: 10,
        iceTransportPolicy: 'all' // Use both UDP and TCP
      });

      // Set up ICE connection timeout
      let iceTimeoutId = setTimeout(() => {
        if (pc && pc.iceConnectionState !== 'connected' && pc.iceConnectionState !== 'completed') {
          console.error("ICE connection timeout - failing after 30 seconds");
          updateCallState("Connection Timeout - Check Network");
          // Don't automatically hang up, let user decide
        }
      }, 30000); // 30 second timeout

      // Clear timeout when ICE connects
      pc.addEventListener('iceconnectionstatechange', () => {
        if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
          clearTimeout(iceTimeoutId);
        }
      });

      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
          console.log("Sending ICE candidate to", remoteClientId);
          ws.send(JSON.stringify({
            event: "call_ice_candidate",
            data: {
              receiver_id: parseInt(remoteClientId),
              message: {
                candidate: event.candidate.toJSON()
              }
            }
          }));
        }
      };

      // Handle remote stream
      pc.ontrack = (event) => {
        console.log("Received remote stream");
        remoteAudio.srcObject = event.streams[0];
        updateCallState("Connected - Audio Playing");
      };

      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        console.log("P2P Connection state:", pc.connectionState);
        if (pc.connectionState === "connected") {
          updateCallState("P2P Connected");
        } else if (pc.connectionState === "disconnected" || pc.connectionState === "failed") {
          updateCallState("P2P Disconnected");
        }
      };

      // Handle ICE connection state changes (more detailed than connection state)
      pc.oniceconnectionstatechange = () => {
        console.log("ICE Connection state:", pc.iceConnectionState);
        switch (pc.iceConnectionState) {
          case "checking":
            updateCallState("Checking connectivity...");
            break;
          case "connected":
            updateCallState("ICE Connected");
            break;
          case "completed":
            updateCallState("ICE Completed - Call Active");
            break;
          case "failed":
            console.error("ICE connection failed - this is likely due to NAT/firewall issues");
            updateCallState("Connection Failed - NAT/Firewall Issue");
            // Attempt restart
            console.log("Attempting ICE restart...");
            pc.restartIce();
            break;
          case "disconnected":
            console.warn("ICE disconnected - network may have changed");
            updateCallState("ICE Disconnected - Network Changed");
            break;
          case "closed":
            updateCallState("ICE Closed");
            break;
        }
      };

      // Handle ICE gathering state
      pc.onicegatheringstatechange = () => {
        console.log("ICE Gathering state:", pc.iceGatheringState);
      };

      // Enhanced ICE candidate handling with error checking
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          console.log("Generated ICE candidate:", event.candidate.type, event.candidate.candidate);
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              event: "call_ice_candidate",
              data: {
                receiver_id: parseInt(remoteClientId),
                message: {
                  candidate: event.candidate.toJSON()
                }
              }
            }));
          } else {
            console.error("Cannot send ICE candidate: WebSocket not open");
          }
        } else {
          console.log("ICE gathering completed");
        }
      };

      // Add local stream
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }
    }

    // Connect to WebSocket signaling server
    async function connectToServer() {
      updateStatus("Checking microphone permission...");
      
      // Check microphone permission first
      const hasPermission = await checkMicrophonePermission();
      if (!hasPermission) {
        return; // Don't connect if no microphone permission
      }
      
      updateStatus("Connecting to server...");
      
      console.log('Connecting to WebSocket proxy:', `${wsProtocol}//${proxyHost}/ws?userId=${clientId}`);
      ws = new WebSocket(`${wsProtocol}//${proxyHost}/ws?userId=${clientId}`);

      ws.onopen = () => {
        updateStatus("Connected to server");
        connectBtn.disabled = true;
        callBtn.disabled = false;
      };

      ws.onclose = () => {
        updateStatus("Disconnected from server");
        connectBtn.disabled = false;
        callBtn.disabled = true;
        hangupBtn.disabled = true;
      };

      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        updateStatus("Connection error");
      };

      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        console.log("Received message:", message);

        // Handle ICE servers response (no sender validation needed)
        if (message.success && message.data && message.data.event === 'call_ice_servers_response') {
          // These are handled by the requestIceServers promise
          return;
        }

        // Handle call_request response from server
        if (message.success !== undefined && message.metadata && message.metadata.request_id) {
          console.log("Received API response:", message);
          if (message.success) {
            console.log("Call request sent successfully to server");
          } else {
            console.error("Call request failed:", message.error);
            updateCallState("Call failed");
            callBtn.disabled = false;
            hangupBtn.disabled = true;
          }
          return;
        }

        // Handle incoming call_request from server
        if (message.event === "call_request" && message.data && message.data.sender_id) {
          console.log("Received incoming call request from server:", message);
          const senderId = message.data.sender_id.toString();
          
          // Only handle calls from the expected remote client
          if (senderId === remoteClientId) {
            console.log("Incoming call from user", senderId);
            await handleIncomingCall(senderId);
          } else {
            console.log("Ignoring call from unexpected sender:", senderId);
          }
          return;
        }

        // Handle incoming call_answer from server
        if (message.event === "call_answer" && message.data && message.data.sender_id) {
          console.log("Received call answer from server:", message);
          const senderId = message.data.sender_id.toString();
          const answerMessage = message.data.message;
          
          // Only handle answer from the expected remote client
          if (senderId === remoteClientId) {
            if (answerMessage && answerMessage.answer === true) {
              console.log("Call accepted by user", senderId);
              await handleCallAccepted();
            } else {
              console.log("Call rejected by user", senderId);
              await handleCallRejected();
            }
          } else {
            console.log("Ignoring call answer from unexpected sender:", senderId);
          }
          return;
        }

        // Handle incoming call_sdp_exchange from server
        if (message.event === "call_sdp_exchange" && message.data && message.data.sender_id) {
          console.log("Received SDP exchange from server:", message);
          const senderId = message.data.sender_id.toString();
          const sdpExchange = message.data.message.sdp_exchange;
          
          // Only handle SDP from the expected remote client
          if (senderId === remoteClientId) {
            console.log("SDP exchange from user", senderId, "type:", sdpExchange.type);
            if (sdpExchange.type === "offer") {
              await handleOffer(sdpExchange);
            } else if (sdpExchange.type === "answer") {
              await handleAnswer(sdpExchange);
            }
          } else {
            console.log("Ignoring SDP exchange from unexpected sender:", senderId);
          }
          return;
        }

        // Handle incoming call_ice_candidate from server
        if (message.event === "call_ice_candidate" && message.data && message.data.sender_id) {
          console.log("Received ICE candidate from server:", message);
          const senderId = message.data.sender_id.toString();
          const candidate = message.data.message.candidate;
          
          // Only handle candidates from the expected remote client
          if (senderId === remoteClientId) {
            console.log("ICE candidate from user", senderId);
            await handleCandidate(candidate);
          } else {
            console.log("Ignoring ICE candidate from unexpected sender:", senderId);
          }
          return;
        }

        // Handle incoming call_hangup from server
        if (message.event === "call_hangup" && message.data && message.data.sender_id) {
          console.log("Received call hangup from server:", message);
          const senderId = message.data.sender_id.toString();
          
          // Only handle hangup from the expected remote client
          if (senderId === remoteClientId) {
            console.log("Call hangup from user", senderId);
            await handleRemoteHangup();
          } else {
            console.log("Ignoring call hangup from unexpected sender:", senderId);
          }
          return;
        }
      };
    }

    // Handle incoming call request
    async function handleIncomingCall(from) {
      console.log("Incoming call from", from);
      updateCallState("Incoming call...");
      
      // Show incoming call UI
      callerName.textContent = from.toUpperCase();
      incomingCallDiv.style.display = "block";
      callBtn.disabled = true;
    }

    // Handle call acceptance
    async function handleCallAccepted() {
      console.log("Call was accepted by", remoteClientId);
      updateCallState("Call accepted, connecting...");
      
      // Enable hangup button as soon as call is accepted
      callBtn.disabled = true;
      hangupBtn.disabled = false;
      muteBtn.disabled = false;
      
      // Now proceed with WebRTC offer/answer exchange
      await initiateWebRTCCall();
    }

    // Handle call rejection
    async function handleCallRejected() {
      console.log("Call was rejected by", remoteClientId);
      updateCallState("Call rejected");
      
      // Reset UI
      resetCallUI();
    }

    // Handle remote hangup
    async function handleRemoteHangup() {
      console.log("Remote client hung up");
      updateCallState("Call ended by remote");
      
      // Close our side of the connection
      hangup(false); // false = don't send hangup message (already received one)
    }

    // Accept incoming call
    async function acceptCall() {
      console.log("Accepting call from", remoteClientId);
      
      // Hide incoming call UI
      incomingCallDiv.style.display = "none";
      
      // Send acceptance message using call_answer event
      ws.send(JSON.stringify({
        event: "call_answer",
        data: {
          receiver_id: parseInt(remoteClientId),
          message: {
            answer: true
          }
        }
      }));
      
      updateCallState("Call accepted, waiting for connection...");
      callBtn.disabled = true;
      hangupBtn.disabled = false;
      muteBtn.disabled = false;
      
      // Get user media ready for when offer comes
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        console.log("Got local stream for accepting call");
      } catch (error) {
        console.error("Error getting media for accepting call:", error);
        if (error.name === 'NotAllowedError') {
          updateCallState("Microphone permission denied. Please allow microphone access.");
          alert("Please allow microphone access to make calls. Check your browser settings.");
        } else if (error.name === 'NotFoundError') {
          updateCallState("No microphone found");
        } else {
          updateCallState("Failed to get microphone: " + error.name);
        }
        // Reset UI since we can't continue without audio
        resetCallUI();
        return;
      }
    }

    // Reject incoming call
    async function rejectCall() {
      console.log("Rejecting call from", remoteClientId);
      
      // Hide incoming call UI
      incomingCallDiv.style.display = "none";
      
      // Send rejection message using call_answer event
      ws.send(JSON.stringify({
        event: "call_answer",
        data: {
          receiver_id: parseInt(remoteClientId),
          message: {
            answer: false
          }
        }
      }));
      
      updateCallState("Call rejected");
      callBtn.disabled = false;
    }

    // Reset call UI to initial state
    function resetCallUI() {
      incomingCallDiv.style.display = "none";
      callBtn.disabled = true;  // Disable call button until reconnected
      hangupBtn.disabled = true;
      muteBtn.disabled = true;
      connectBtn.disabled = false;  // Enable connect button for reconnection
      
      // Reset mute state
      isMuted = false;
      muteBtn.innerHTML = "ðŸŽ¤ Mute";
      muteBtn.style.background = "#ff9800";
    }

    // Initiate WebRTC call (after call acceptance)
    async function initiateWebRTCCall() {
      try {
        // Get user media if not already obtained
        if (!localStream) {
          try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log("Got local stream for WebRTC call");
          } catch (mediaError) {
            console.error("Error getting media for WebRTC call:", mediaError);
            if (mediaError.name === 'NotAllowedError') {
              updateCallState("Microphone permission denied. Please allow microphone access.");
              alert("Please allow microphone access to make calls. Check your browser settings.");
            } else if (mediaError.name === 'NotFoundError') {
              updateCallState("No microphone found");
            } else {
              updateCallState("Failed to get microphone: " + mediaError.name);
            }
            resetCallUI();
            return;
          }
        }

        // Create peer connection
        await createPeerConnection();

        // Create offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        // Send offer to remote client using SDP exchange
        ws.send(JSON.stringify({
          event: "call_sdp_exchange",
          data: {
            receiver_id: parseInt(remoteClientId),
            message: {
              sdp_exchange: offer
            }
          }
        }));

        updateCallState("Sending offer...");
        hangupBtn.disabled = false; // Enable hangup for caller
        muteBtn.disabled = false; // Enable mute for caller

      } catch (error) {
        console.error("Error initiating WebRTC call:", error);
        updateCallState("Call failed: " + error.message);
      }
    }

    // Handle incoming offer (Client B becomes answerer)
    async function handleOffer(offer) {
      console.log("Received offer from", remoteClientId);
      updateCallState("Received offer, creating answer...");

      if (!pc) await createPeerConnection();

      await pc.setRemoteDescription(offer);
      
      // Process any queued ICE candidates now that remote description is set
      await processPendingCandidates();
      
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // Send answer back using SDP exchange
      ws.send(JSON.stringify({
        event: "call_sdp_exchange",
        data: {
          receiver_id: parseInt(remoteClientId),
          message: {
            sdp_exchange: answer
          }
        }
      }));

      updateCallState("Answer sent, connecting...");
      callBtn.disabled = true;
      hangupBtn.disabled = false;
      muteBtn.disabled = false;
    }

    // Handle incoming answer
    async function handleAnswer(answer) {
      console.log("Received answer from", remoteClientId);
      await pc.setRemoteDescription(answer);
      
      // Process any queued ICE candidates now that remote description is set
      await processPendingCandidates();
      
      updateCallState("Call connected");
      hangupBtn.disabled = false; // Ensure hangup stays enabled for caller
      muteBtn.disabled = false; // Enable mute button when call is connected
    }

    // Handle incoming ICE candidate with queuing for timing issues
    async function handleCandidate(candidate) {
      console.log("Received ICE candidate from", remoteClientId, "type:", candidate.type);
      
      if (pc && pc.remoteDescription) {
        // Remote description is set, add candidate immediately
        try {
          await pc.addIceCandidate(candidate);
          console.log("Successfully added ICE candidate");
        } catch (error) {
          console.error("Failed to add ICE candidate:", error);
        }
      } else {
        // Remote description not set yet, queue the candidate
        console.log("Queuing ICE candidate until remote description is set");
        pendingIceCandidates.push(candidate);
      }
    }

    // Process queued ICE candidates after remote description is set
    async function processPendingCandidates() {
      console.log(`Processing ${pendingIceCandidates.length} pending ICE candidates`);
      
      for (const candidate of pendingIceCandidates) {
        try {
          await pc.addIceCandidate(candidate);
          console.log("Successfully added queued ICE candidate:", candidate.type);
        } catch (error) {
          console.error("Failed to add queued ICE candidate:", error);
        }
      }
      
      // Clear the queue
      pendingIceCandidates = [];
    }

    // Initiate call (Client B becomes caller)
    async function makeCall() {
      try {
        updateCallState("Requesting call...");

        // Send call request (simplified format)
        ws.send(JSON.stringify({
          event: "call_request",
          data: {
            receiver_id: parseInt(remoteClientId)
          }
        }));

        updateCallState("Calling...");
        callBtn.disabled = true;

      } catch (error) {
        console.error("Error making call:", error);
        updateCallState("Call failed: " + error.message);
        callBtn.disabled = false;
      }
    }

    // Hang up call
    function hangup(sendHangupMessage = true) {
      console.log("Hanging up call");

      // Send hangup message to remote client (unless we're hanging up due to remote hangup)
      if (sendHangupMessage && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          event: "call_hangup",
          data: {
            receiver_id: parseInt(remoteClientId)
          }
        }));
      }

      // Close peer connection
      if (pc) {
        pc.close();
        pc = null;
      }

      // Clear any pending ICE candidates
      pendingIceCandidates = [];

      // Stop local stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      // Clear remote audio
      remoteAudio.srcObject = null;
      
      // Reset UI
      updateCallState("Call ended - Disconnecting...");
      resetCallUI();
      
      // Close WebSocket connection to force clean reconnection
      if (ws) {
        console.log("Closing WebSocket connection for clean state");
        ws.close();
        ws = null;
      }
      
      // Update UI to show disconnected state
      updateStatus("Disconnected - Click Connect to make new calls");
    }

    // Event listeners
    connectBtn.addEventListener("click", connectToServer);
    callBtn.addEventListener("click", makeCall);
    hangupBtn.addEventListener("click", () => hangup(true));
    muteBtn.addEventListener("click", toggleMute);
    acceptBtn.addEventListener("click", acceptCall);
    rejectBtn.addEventListener("click", rejectCall);

    console.log("Client B initialized");
  </script>
</body>
</html>
